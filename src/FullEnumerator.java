import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;

/**
 * The {@code FullEnumerator} is the the final version of enumerator
 * for all arithmetically distinct expressions in form of variables
 * given a list of variable expressions.
 * <p>
 * The enumerator guarantee the completeness and correctness of distinct expressions
 * when considering that all variables denoted with different names are different.
 * The redundancy removal algorithm implemented can significantly decrease the number
 * of expressions enumerated. For example, in case of 4 variables, there are literally
 * 9216 different expressions, which can be pruned to 1170 distinct ones, as confirmed
 * in <a href="https://oeis.org/A140606">A140606-OEIS</a>.
 * <p>
 * The enumerator doesn't guarantee the free of redundancy when the variables
 * are evaluated with certain substitutions.
 */
public class FullEnumerator {
  private List<Expression> allExpList = new LinkedList<>();

  /**
   * Returns all expressions generated by full combinations of variables in {@code expList}
   * All expressions in arithmetically distinct given that variables are different
   *
   * @param expList List of variables
   * @return List of all expression combinations
   */
  public List<Expression> getAllExpressions(List<Expression> expList) {
    enumerate(expList, 1);

    ArrayList<Expression> ret = new ArrayList<>();
    for (Expression exp : allExpList) {
      ret.add(exp.makeCopy());
    }
    allExpList.clear();
    return ret;
  }

  private void enumerate(List<Expression> expList, int minJ) {
    if (expList.size() == 1) {
      // When there's only one expression left in expression list, add it to result list
      allExpList.add(expList.get(0));
    } else {
      for (int j = minJ; j < expList.size(); j++) {
        for (int i = 0; i < j; i++) {
          // pick two expressions in the list, combine them and add it back to the list
          for (Expression newExp : combine(expList.get(i), expList.get(j))) {
            List<Expression> newExpList = new ArrayList<>();
            for (int k = 0; k < expList.size(); k++)
              if (k != i && k != j)
                newExpList.add(expList.get(k));

            newExp.id = expList.get(expList.size() - 1).id + 1;
            newExpList.add(newExp);
            enumerate(newExpList, j - 1);
          }
        }
      }
    }
  }

  /**
   * Returns all combinations with left operand {@code expA} and right operand {@code expB}
   *
   * @param expA left operand
   * @param expB right operand
   * @return List of all combinations
   */
  private List<Expression> combine(Expression expA, Expression expB) {
    List<Expression> result = new ArrayList<>();

    // PLUS
    if (expA.operator != Operator.PLUS && expA.operator != Operator.MINUS
        && expB.operator != Operator.MINUS
        && (expB.operator != Operator.PLUS || expA.id < ((BiOperandExp) expB).leftOperand.id)) {
      int polar;
      if (expA.polar == 0 && expB.polar == 0)
        polar = 0;
      else if (expA.polar == 0 || expB.polar == 0)
        polar = 1;
      else
        polar = expB.polar;
      result.add(new BiOperandExp(Operator.PLUS, expA, expB, polar));
    }

    // MINUS
    if (expA.operator != Operator.MINUS && expB.operator != Operator.MINUS) {
      if (expA.polar == 0 && expB.polar == 0) {
        result.add(new BiOperandExp(Operator.MINUS, expA, expB, 1));
        result.add(new BiOperandExp(Operator.MINUS, expB, expA, -1));
      } else {
        if (expA.polar == 0)
          result.add(new BiOperandExp(Operator.MINUS, expB, expA, -1));
        if (expB.polar == 0)
          result.add(new BiOperandExp(Operator.MINUS, expA, expB, -1));
      }
    }

    // MULTIPLY
    if (expA.operator != Operator.PRODUCT && expA.operator != Operator.DIVISION
        && expB.operator != Operator.DIVISION
        && (expB.operator != Operator.PRODUCT || expA.id < ((BiOperandExp) expB).leftOperand.id)) {
      if (expA.polar == 0 || expB.polar == 0)
        result.add(new BiOperandExp(Operator.PRODUCT, expA, expB, expA.polar + expB.polar));
      else if (expA.polar > 0)
        result.add(new BiOperandExp(Operator.PRODUCT, expA, expB, expB.polar));
    }

    // DIVISION
    if (expA.operator != Operator.DIVISION && expB.operator != Operator.DIVISION) {
      if (expA.polar == 0 || expB.polar == 0) {
        result.add(new BiOperandExp(Operator.DIVISION, expA, expB, expA.polar + expB.polar));
        result.add(new BiOperandExp(Operator.DIVISION, expB, expA, expA.polar + expB.polar));
      } else {
        if (expA.polar > 0)
          result.add(new BiOperandExp(Operator.DIVISION, expA, expB, expB.polar));
        if (expB.polar > 0)
          result.add(new BiOperandExp(Operator.DIVISION, expB, expA, expA.polar));
      }
    }

    return result;
  }

  public static void main(String[] args) {
    System.out.println(Utils.factorial(4).intValue() * (int) Math.pow(4, 3) * Utils.factorial(3).intValue());
    System.out.println(new FullEnumerator().getAllExpressions(Var.getVarList(4)).size());
  }
}
